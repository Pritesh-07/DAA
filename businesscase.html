<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Pritesh Kotur</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <meta content="" name="keywords">
    <meta content="" name="description">

    <!-- Favicon -->
    <link href="img/favicon.ico" rel="icon">

    <!-- Google Web Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@400;500&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet"> 

    <!-- Icon Font Stylesheet -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.4.1/font/bootstrap-icons.css" rel="stylesheet">

    <!-- Libraries Stylesheet -->
    <link href="lib/animate/animate.min.css" rel="stylesheet">
    <link href="lib/owlcarousel/assets/owl.carousel.min.css" rel="stylesheet">
    <link href="lib/lightbox/css/lightbox.min.css" rel="stylesheet">

    <!-- Customized Bootstrap Stylesheet -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Template Stylesheet -->
    <link href="css/style.css" rel="stylesheet">
</head>
<style>
    .code-container {
        background-color: #282c34;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        color: #fff;
        font-family: 'Courier New', monospace;
    }

    .code-container h3 {
        text-align: center;
        color: #00bcd4;
        margin-bottom: 20px;
    }

    .code-box {
        background-color: #2d2d2d;
        padding: 20px;
        border-radius: 8px;
        overflow-x: auto;
    }

    pre {
        margin: 0;
        font-size: 1rem;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    code {
        color: #f8f8f2;
    }

    .cpp {
        color: #f8f8f2;
    }

    .cpp .keyword {
        color: #ff79c6;
    }

    .cpp .string {
        color: #f1fa8c;
    }

    .cpp .number {
        color: #bd93f9;
    }

    .cpp .comment {
        color: #6272a4;
        font-style: italic;
    }
</style>

<body>
    <div class="container-xxl bg-white p-0">
        <!-- Spinner Start -->
      


        <!-- Navbar & Hero Start -->
        <div class="container-xxl position-relative p-0">
            <nav class="navbar navbar-expand-lg navbar-light px-4 px-lg-5 py-3 py-lg-0">
                <a href="" class="navbar-brand p-0">
                    <h1 class="m-0"><span class="fs-5">DAA</span></h1>
                    <!-- <img src="img/logo.png" alt="Logo"> -->
                </a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse">
                    <span class="fa fa-bars"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarCollapse">
                    <div class="navbar-nav ms-auto py-0">
                        <a href="index.html" class="nav-item nav-link ">Introduction</a>
                        <a href="courseproject.html" class="nav-item nav-link active">Course Project</a>
                        <a href="coursereflexation.html" class="nav-item nav-link">Course Reflections</a>            
                    </div>
                </div>
            </nav>

            <div class="container-xxl py-5 bg-primary hero-header mb-5">
                <div class="container my-5 py-5 px-lg-5">
                    <div class="row g-5 py-5">
                        <div class="col-12 text-center">
                            <h1 class="text-white animated zoomIn">Businesses Case</h1>
                            <hr class="bg-white mx-auto mt-0" style="width: 90px;">
                            <nav aria-label="breadcrumb">
                                <ol class="breadcrumb justify-content-center" style="margin-right:2rem;">
                                    <li class="breadcrumb-item"><a class="text-white" href="#">Introduction</a></li>
                                    <li class="breadcrumb-item"><a class="text-white" href="#">Course Project</a></li>
                                    <li class="breadcrumb-item text-white active" aria-current="page">Course Reflections</li>
                                </ol>
                            </nav>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Navbar & Hero End -->


        <div class="container-xxl bg-primary newsletter my-5 wow fadeInUp" data-wow-delay="0.1s">
            <div class="container px-lg-5" style="height:auto;">
                <div class="row align-items-center" style="height:auto;">
                    <div class="col-12 col-md-6">
                        <h3 class="text-white" style="text-decoration: underline; margin-top:3.5rem">
                            Smart Traffic Management System
                        </h3>
                        <div class="w-100 mt-3" style="text-align: justify; color: whitesmoke; font-family: Georgia;">
                            Growing traffic congestion, ineffective traffic management, and growing road safety issues are 
                            major challenges for urban regions around the world. Due to their inability to adjust to 
                            real-time traffic circumstances and their fixed signal timings and manual interventions, 
                            traditional traffic systems frequently result in accidents, delays, and increased fuel consumption 
                            and carbon emissions. Additionally, these problems are made worse by the absence of predictive 
                            methods for addressing crises and peak-hour traffic, which has a detrimental effect on commuters 
                            and urban mobility. This emphasizes the necessity of an intelligent, real-time solution that makes 
                            use of cutting-edge technology like machine learning, the Internet of Things, and optimization 
                            algorithms in order to dynamically control traffic flow, lessen congestion, and improve road safety. 
                            In order to overcome these obstacles, a Smart Traffic Management System (STMS) offers an effective, 
                            data-driven, and adaptable traffic control system.
                        </div>
                        <div class="w-100 mt-4" style="text-align: justify; color: whitesmoke; font-family: Georgia; font-weight: bold;">
                            <strong>SDG 11.2:</strong> Provide access to safe, affordable, accessible, and sustainable transport 
                            systems for all, improving road safety, notably by expanding public transport, with special attention 
                            to the needs of those in vulnerable situations, women, children, persons with disabilities, and older 
                            persons.
                        </div>
                        <div class="w-100 mt-4" style="text-align: justify; color: whitesmoke; font-family: Georgia;  font-weight: bold;">
                            Traffic congestion is a major issue in urban areas, leading to increased travel time, fuel consumption, 
                            and air pollution. This use case aims to create a city with regular and proper management of traffic.
                        </div>
                        <div class="w-100 mt-4" style="text-align: justify; color: whitesmoke; font-family: Georgia; font-weight: bold;">
                            <strong>Indicator 11.2.1:</strong> Proportion of population that has convenient access to public transport, 
                            by sex, age, and persons with disabilities.
                        </div>
                        <div class="w-100 mt-4" style="text-align: justify; color: whitesmoke; font-family: Georgia; font-weight: bold;">
                            For this business case, the primary objective is the need to find a way in which there is no traffic 
                            coagulation. In other words, we can say that a way which has no cycles. So for this use case, we can 
                            use Kruskal's algorithm which gives us the Minimum Spanning Tree (MST), a way which connects all the 
                            vertices without having any cycles.
                        </div>
                    </div>
                    <div class="col-md-6 text-center mb-n5 d-none d-md-block">
                        <!-- Lottie Animation -->
                        <iframe src="https://lottie.host/embed/d19a2f40-f3ee-45fb-ae54-029f3a22627f/V3AmvjqHMY.lottie" style="height: 20rem;"></iframe>
                    </div>
                </div>
            </div>
        </div>
        
        

        <div class="container-xxl py-5 bg-light">
            <div class="container">
                <div class="section-title text-center mb-5">
                    <h2 class="text-primary fw-bold wow zoomIn" data-wow-delay="0.1s">Algorithmic Problem-Solving Techniques in STMS</h2>
                    <p class="text-muted wow fadeInUp" data-wow-delay="0.2s">
                        Discover how advanced algorithms optimize smart traffic management systems for efficiency and sustainability.
                    </p>
                </div>
        
                <div class="row g-5">
                    <!-- Dijkstra’s Algorithm -->
                    <div class="col-lg-4 col-md-6">
                        <div class="card shadow-sm wow slideInLeft" data-wow-delay="0.3s">
                            <div class="card-body text-center">
                                <div class="icon-box mb-4">
                                    <i class="bi bi-geo-alt text-primary fs-1"></i>
                                </div>
                                <h5 class="card-title fw-bold">Dijkstra’s Algorithm</h5>
                                <p class="card-text">
                                    <strong>Purpose:</strong> Finds the shortest path between two points.<br>
                                    <strong>Applications:</strong> Real-time route optimization, dynamic rerouting to avoid congestion, and shortest path calculations in navigation systems.<br>
                                    <strong>Working:</strong> Weighted graphs with nodes as intersections and edges as roads, using traffic density as weights.
                                </p>
                            </div>
                        </div>
                    </div>
        
                    <!-- AVL Tree -->
                    <div class="col-lg-4 col-md-6">
                        <div class="card shadow-sm wow zoomIn" data-wow-delay="0.4s">
                            <div class="card-body text-center">
                                <div class="icon-box mb-4">
                                    <i class="bi bi-diagram-3 text-success fs-1"></i>
                                </div>
                                <h5 class="card-title fw-bold">AVL Tree</h5>
                                <p class="card-text">
                                    <strong>Purpose:</strong> Maintains a sorted dataset with self-balancing properties.<br>
                                    <strong>Applications:</strong> Fast indexing of live traffic data, adaptive signal control, and emergency vehicle prioritization.<br>
                                    <strong>Advantages:</strong> Ensures O(log n) efficiency for real-time data retrieval and updates.
                                </p>
                            </div>
                        </div>
                    </div>
        
                    <!-- Kruskal’s Algorithm -->
                    <div class="col-lg-4 col-md-6">
                        <div class="card shadow-sm wow slideInRight" data-wow-delay="0.5s">
                            <div class="card-body text-center">
                                <div class="icon-box mb-4">
                                    <i class="bi bi-graph-up text-warning fs-1"></i>
                                </div>
                                <h5 class="card-title fw-bold">Kruskal’s Algorithm</h5>
                                <p class="card-text">
                                    <strong>Purpose:</strong> Finds the minimum spanning tree (MST) in a graph.<br>
                                    <strong>Applications:</strong> Optimizes road network layouts, minimizes sensor installation costs, and ensures connectivity for resource scaling.<br>
                                    <strong>Advantages:</strong> Handles sparse graphs efficiently for scalable urban planning.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="container-xxl py-5 bg-light">
            <div class="container">
        
                <!-- Step-by-Step Algorithm Section -->
                <div class="section-title text-center mt-5">
                    <h3 class="text-primary fw-bold wow zoomIn" data-wow-delay="0.1s">Step-by-Step Algorithm</h3>
                    <p class="text-muted wow fadeInUp" data-wow-delay="0.2s">Detailed step-by-step breakdown of each algorithm for better understanding.</p>
                </div>
        
                <div class="row">
                    <!-- Kruskal's Algorithm -->
                    <div class="col-md-4">
                        <div class="card shadow-lg border-0 rounded-3">
                            <div class="card-body">
                                <h5 class="card-title fw-bold">Kruskal's Algorithm for Sensor Placement</h5>
                                <p><strong>Objective:</strong> Find the optimal placement of sensors using the Minimum Spanning Tree (MST).</p>
                                <p><strong>Steps:</strong></p>
                                <ul class="list-group list-group-flush">
                                    <li class="list-group-item">1. Sort all edges by weight (cost).</li>
                                    <li class="list-group-item">2. Initialize a Disjoint-Set (Union-Find) data structure.</li>
                                    <li class="list-group-item">3. Iterate through all edges in sorted order:</li>
                                    <li class="list-group-item">   a. Use the find operation to check if the edge connects different components.</li>
                                    <li class="list-group-item">   b. If they are in different components, add the edge to the MST using the union operation.</li>
                                    <li class="list-group-item">4. Stop when the MST contains V-1 edges (V = number of vertices).</li>
                                    <li class="list-group-item">5. Output the selected edges for the MST (optimal sensor placement).</li>
                                </ul>
                            </div>
                        </div>
                    </div>
        
                    <!-- Dijkstra's Algorithm -->
                    <div class="col-md-4">
                        <div class="card shadow-lg border-0 rounded-3">
                            <div class="card-body">
                                <h5 class="card-title fw-bold">Dijkstra's Algorithm for Traffic Routing</h5>
                                <p><strong>Objective:</strong> Find the shortest path from a starting intersection to all other intersections.</p>
                                <p><strong>Steps:</strong></p>
                                <ul class="list-group list-group-flush">
                                    <li class="list-group-item">1. Initialize a priority queue (min-heap) to track the node with the smallest distance.</li>
                                    <li class="list-group-item">2. Set the distance to the source node as 0 and all others as infinity (INT_MAX).</li>
                                    <li class="list-group-item">3. Start from the source node and push it into the priority queue.</li>
                                    <li class="list-group-item">4. Extract the node with the minimum distance from the priority queue.</li>
                                    <li class="list-group-item">5. Relax all adjacent edges, update distances for neighbors, and push updated distances into the priority queue.</li>
                                    <li class="list-group-item">6. Repeat until all nodes are processed.</li>
                                    <li class="list-group-item">7. Output the shortest distance from the source to each destination node.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
        
                    <!-- AVL Tree for Data Storage -->
                    <div class="col-md-4">
                        <div class="card shadow-lg border-0 rounded-3">
                            <div class="card-body">
                                <h5 class="card-title fw-bold">AVL Tree for Traffic Data Storage</h5>
                                <p><strong>Objective:</strong> Store and maintain traffic data efficiently using a balanced tree structure.</p>
                                <p><strong>Steps:</strong></p>
                                <ul class="list-group list-group-flush">
                                    <li class="list-group-item">1. Insert traffic data (intersection name and vehicle count) into the AVL tree.</li>
                                    <li class="list-group-item">2. Balance the tree after each insertion to maintain height difference between left and right subtrees ≤ 1.</li>
                                    <li class="list-group-item">3. Perform rotations (left or right) to maintain balance when necessary.</li>
                                    <li class="list-group-item">4. Perform an in-order traversal to print traffic data sorted by intersection names.</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Workflow Section Title -->
<div class="section-title text-center mt-5">
    <h3 class="text-primary fw-bold wow zoomIn" data-wow-delay="0.1s">Workflow for STMS Implementation</h3>
    <p class="text-muted wow fadeInUp" data-wow-delay="0.2s">Follow this structured workflow for seamless STMS deployment and optimization.</p>
</div>

<!-- Workflow Steps -->
<div class="row g-4">
    <!-- Step 1: Graph Setup -->
    <div class="col-md-6 wow fadeInLeft" data-wow-delay="0.3s">
        <div class="card shadow-lg border-0 rounded-3 overflow-hidden">
            <div class="card-body">
                <h5 class="card-title fw-bold">1. Graph Setup (Road Network)</h5>
                <div class="icon-box mb-4">
                    <i class="bi bi-map text-info fs-2"></i>
                </div>
                <p>Create a graph representing the road network with edges between intersections, each edge weighted by road lengths or travel times.</p>
            </div>
        </div>
    </div>

    <!-- Step 2: Kruskal's Algorithm for Sensor Placement -->
    <div class="col-md-6 wow fadeInRight" data-wow-delay="0.4s">
        <div class="card shadow-lg border-0 rounded-3 overflow-hidden">
            <div class="card-body">
                <h5 class="card-title fw-bold">2. Kruskal's Algorithm for Sensor Placement</h5>
                <div class="icon-box mb-4">
                    <i class="bi bi-gear-fill text-success fs-2"></i>
                </div>
                <p>Sort the graph edges by weight and apply Kruskal’s Algorithm to determine the Minimum Spanning Tree (MST), identifying where sensors should be placed to minimize monitoring costs.</p>
            </div>
        </div>
    </div>

    <!-- Step 3: Dijkstra’s Algorithm for Routing -->
    <div class="col-md-6 wow fadeInLeft" data-wow-delay="0.5s">
        <div class="card shadow-lg border-0 rounded-3 overflow-hidden">
            <div class="card-body">
                <h5 class="card-title fw-bold">3. Dijkstra’s Algorithm for Routing</h5>
                <div class="icon-box mb-4">
                    <i class="bi bi-arrow-right-circle-fill text-primary fs-2"></i>
                </div>
                <p>Use Dijkstra's algorithm to calculate the shortest paths from a given source intersection to all other intersections, optimizing traffic flow.</p>
            </div>
        </div>
    </div>

    <!-- Step 4: AVL Tree for Traffic Data Storage -->
    <div class="col-md-6 wow fadeInRight" data-wow-delay="0.6s">
        <div class="card shadow-lg border-0 rounded-3 overflow-hidden">
            <div class="card-body">
                <h5 class="card-title fw-bold">4. AVL Tree for Traffic Data Storage</h5>
                <div class="icon-box mb-4">
                    <i class="bi bi-archive-fill text-warning fs-2"></i>
                </div>
                <p>Store traffic data (vehicle counts) in an AVL tree to maintain a balanced structure, ensuring efficient data retrieval and updates.</p>
            </div>
        </div>
    </div>

    <!-- Step 5: Output Results -->
    <div class="col-md-6 wow fadeInLeft" data-wow-delay="0.7s">
        <div class="card shadow-lg border-0 rounded-3 overflow-hidden">
            <div class="card-body">
                <h5 class="card-title fw-bold">5. Output Results</h5>
                <div class="icon-box mb-4">
                    <i class="bi bi-bar-chart-fill text-danger fs-2"></i>
                </div>
                <p>Display the MST edges for sensor placement, the shortest path from the source to all other intersections, and the sorted traffic data from the AVL tree.</p>
            </div>
        </div>
    </div>
</div>

<!-- CSS for Spacing and Alignment Fixes -->


                </div>
            </div>
        </div>

        
        <div class="code-container">
            <h3 class="text-center  mt-4">C++ Code for Smart Traffic Management System</h3>
            <div class="code-box">
                <pre><code class="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;

using namespace std;

// Dijkstra's Algorithm for Traffic Routing
struct DijkstraGraph {
    unordered_map<string, unordered_map<string, int>> adjList;

    void addEdge(const string& u, const string& v, int weight) {
        adjList[u][v] = weight;
        adjList[v][u] = weight;
    }

    unordered_map<string, int> dijkstra(const string& start) {
        unordered_map<string, int> dist;
        for (auto& node : adjList) {
            dist[node.first] = INT_MAX;
        }
        dist[start] = 0;

        priority_queue<pair<int, string>, vector<pair<int, string>>, greater<>> pq;
        pq.push({0, start});

        while (!pq.empty()) {
            int currentDist = pq.top().first;
            string currentNode = pq.top().second;
            pq.pop();

            if (currentDist > dist[currentNode]) continue;

            for (auto& neighbor : adjList[currentNode]) {
                string nextNode = neighbor.first;
                int weight = neighbor.second;
                int newDist = currentDist + weight;

                if (newDist < dist[nextNode]) {
                    dist[nextNode] = newDist;
                    pq.push({newDist, nextNode});
                }
            }
        }
        return dist;
    }
};

// AVL Tree for Traffic Data Storage
struct AVLNode {
    string key;
    int value;
    int height;
    AVLNode* left;
    AVLNode* right;

    AVLNode(const string& key, int value)
        : key(key), value(value), height(1), left(nullptr), right(nullptr) {}
};

struct AVLTree {
    AVLNode* root;

    AVLTree() : root(nullptr) {}

    int height(AVLNode* node) {
        return node ? node->height : 0;
    }

    int balanceFactor(AVLNode* node) {
        return node ? height(node->left) - height(node->right) : 0;
    }

    AVLNode* rotateRight(AVLNode* y) {
        AVLNode* x = y->left;
        AVLNode* T2 = x->right;
        x->right = y;
        y->left = T2;

        y->height = max(height(y->left), height(y->right)) + 1;
        x->height = max(height(x->left), height(x->right)) + 1;

        return x;
    }

    AVLNode* rotateLeft(AVLNode* x) {
        AVLNode* y = x->right;
        AVLNode* T2 = y->left;
        y->left = x;
        x->right = T2;

        x->height = max(height(x->left), height(x->right)) + 1;
        y->height = max(height(y->left), height(y->right)) + 1;

        return y;
    }

    AVLNode* insert(AVLNode* node, const string& key, int value) {
        if (!node) return new AVLNode(key, value);

        if (key < node->key)
            node->left = insert(node->left, key, value);
        else if (key > node->key)
            node->right = insert(node->right, key, value);
        else
            return node;

        node->height = 1 + max(height(node->left), height(node->right));

        int balance = balanceFactor(node);

        if (balance > 1 && key < node->left->key) {
            return rotateRight(node);
        }

        if (balance < -1 && key > node->right->key) {
            return rotateLeft(node);
        }

        if (balance > 1 && key > node->left->key) {
            node->left = rotateLeft(node->left);
            return rotateRight(node);
        }

        if (balance < -1 && key < node->right->key) {
            node->right = rotateRight(node->right);
            return rotateLeft(node);
        }

        return node;
    }

    void inOrder(AVLNode* node) {
        if (node) {
            inOrder(node->left);
            cout << node->key << ": " << node->value << endl;
            inOrder(node->right);
        }
    }

    void insert(const string& key, int value) {
        root = insert(root, key, value);
    }

    void display() {
        inOrder(root);
    }
};

// Kruskal's Algorithm for Sensor Placement
struct DisjointSet {
    vector<int> parent, rank;

    DisjointSet(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    int find(int x) {
        if (x != parent[x]) parent[x] = find(parent[x]);
        return parent[x];
    }

    void unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
};

struct Edge {
    int u, v, weight;

    Edge(int u, int v, int weight) : u(u), v(v), weight(weight) {}

    bool operator<(const Edge& e) const {
        return weight < e.weight;
    }
};

struct KruskalGraph {
    int V;
    vector<Edge> edges;

    KruskalGraph(int V) : V(V) {}

    void addEdge(int u, int v, int weight) {
        edges.push_back(Edge(u, v, weight));
    }

    void kruskal() {
        sort(edges.begin(), edges.end());

        DisjointSet ds(V);
        vector<Edge> mst;

        for (Edge& e : edges) {
            int u = e.u;
            int v = e.v;

            if (ds.find(u) != ds.find(v)) {
                ds.unionSets(u, v);
                mst.push_back(e);
            }
        }

        cout << "Selected edges for sensor placement (MST):" << endl;
        for (Edge& e : mst) {
            cout << "Edge: " << e.u << " - " << e.v << ", Cost: " << e.weight << endl;
        }
    }
};

int main() {
    // 1. Graph Setup (Road Network)
    int V, E;
    cout << "Enter the number of vertices and edges: ";
    cin >> V >> E;

    KruskalGraph g(V);
    cout << "Enter the edges (u v weight):" << endl;
    for (int i = 0; i < E; i++) {
        int u, v, weight;
        cin >> u >> v >> weight;
        g.addEdge(u, v, weight);
    }

    cout << "Optimal Sensor Placement using Kruskal's Algorithm:" << endl;
    g.kruskal();

    // 2. Dijkstra's Algorithm for Routing
    int edges;
    cout << "\nEnter the number of edges in the road network: ";
    cin >> edges;

    DijkstraGraph roadNetwork;
    cout << "Enter the edges (source destination weight):" << endl;
    for (int i = 0; i < edges; i++) {
        string u, v;
        int weight;
        cin >> u >> v >> weight;
        roadNetwork.addEdge(u, v, weight);
    }

    string start;
    cout << "Enter the starting point for Dijkstra's Algorithm: ";
    cin >> start;

    unordered_map<string, int> shortestPaths = roadNetwork.dijkstra(start);
    cout << "\nShortest Path from " << start << " to other intersections (using Dijkstra's Algorithm):" << endl;
    for (auto& node : shortestPaths) {
        cout << start << " to " << node.first << " : " << node.second << endl;
    }

    // 3. AVL Tree for Traffic Data
    int intersections;
    cout << "\nEnter the number of intersections: ";
    cin >> intersections;

    AVLTree trafficData;
    cout << "Enter the traffic data (intersection traffic_count):" << endl;
    for (int i = 0; i < intersections; i++) {
        string intersection;
        int traffic;
        cin >> intersection >> traffic;
        trafficData.insert(intersection, traffic);
    }

    cout << "\nTraffic Data at Intersections (AVL Tree):" << endl;
    trafficData.display();

    return 0;
}

                </code></pre>
            </div>
            1. Optimal Sensor Placement (Kruskal's Algorithm)
            <strong>          Extra Information about code : <br> <br>
<hr>
Input:A graph with 4 nodes (0, 1, 2, 3) and weighted edges representing the cost of placing sensors between intersections:
<br>
(0, 1, weight 1) <br>
(1, 2, weight 2) <br>
(2, 3, weight 3) <br>
(0, 2, weight 2) <br>
(1, 3, weight 1) <br>
Execution:
Sort Edges by Weight: <br>
 <br>
The edges are sorted in ascending order of weights: <br>
(0, 1, 1), (1, 3, 1), (1, 2, 2), (0, 2, 2), (2, 3, 3). <br>
Initialize Disjoint Sets: <br>

Each node starts as its own parent, representing separate sets: <br>
Parent array: [0, 1, 2, 3]. <br>
Rank array: [0, 0, 0, 0]. <br> <br>
Iterate through Sorted Edges: <br>

For each edge, check if adding it forms a cycle using the Disjoint Set data structure. If not, add the edge to the Minimum Spanning Tree (MST).
<br>
Edge (0, 1, 1): <br>
Find(0) = 0, Find(1) = 1 (different sets). <br>
Union(0, 1): Parent[1] = 0. <br>
MST: [(0, 1, 1)]. <br>

Edge (1, 3, 1): <br>
Find(1) → Find(0) = 0, Find(3) = 3 (different sets). <br>
Union(1, 3): Parent[3] = 0. <br>
MST: [(0, 1, 1), (1, 3, 1)]. <br>

Edge (1, 2, 2): <br>
Find(1) → Find(0) = 0, Find(2) = 2 (different sets). <br>
Union(1, 2): Parent[2] = 0. <br>
MST: [(0, 1, 1), (1, 3, 1), (1, 2, 2)]. <br>
Edge (0, 2, 2): Skipped (forms a cycle). <br>
Edge (2, 3, 3): Skipped (forms a cycle). <br>

Output: <br>
The Minimum Spanning Tree (MST), representing the optimal edges for sensor placement:<br>

(0, 1, weight 1)<br>
(1, 3, weight 1)<br>
(1, 2, weight 2) <br>

2. Traffic Routing (Dijkstra's Algorithm)
<hr>
Input:
A graph with intersections and edges representing travel times: <br>

Intersections: A, B, C, D. <br>
Edges: <br>
A → B (1), A → C (4), B → C (2), B → D (6), C → D (3). <br>
Start Point: A. <br>
Execution: <br>

Initialize Distances: <br>
Priority Queue: [(0, A)]. <br>
Distances: {A: 0, B: ∞, C: ∞, D: ∞} (distance to A is 0; others are initially ∞). <br>
Process Nodes: <br>


Node A (distance 0): <br>
A → B: New distance = 0 + 1 = 1 (update B).
Relax neighbors: <br>
Distances: {A: 0, B: 1, C: 4, D: ∞}. <br>
A → C: New distance = 0 + 4 = 4 (update C). <br>
Queue: [(1, B), (4, C)]. <br>
Node B (distance 1): <br>

B → C: New distance = 1 + 2 = 3 (update C). <br>
Relax neighbors: <br>
B → D: New distance = 1 + 6 = 7 (update D). <br>
Distances: {A: 0, B: 1, C: 3, D: 7}. <br>
Queue: [(3, C), (4, C), (7, D)]. <br>
Node C (distance 3): <br>

C → D: New distance = 3 + 3 = 6 (update D). <br>
Relax neighbors: <br>
Distances: {A: 0, B: 1, C: 3, D: 6}. <br>
Queue: [(4, C), (7, D), (6, D)]. <br>
Node D (distance 6): <br>

No updates, as all distances are already optimal. <br>
Output: <br>

The shortest paths from A to other intersections: <br>
A → B: 1 <br>
A → A: 0 <br>
A → C: 3 <br>
A → D: 6 <br>
<br>
3. Traffic Data Storage (AVL Tree)
<br>
Input:

Traffic data at intersections with vehicle counts: <br>
Intersection B: 50 <br>
Intersection A: 30 <br>
Intersection C: 40 <br>
Intersection D: 20 <br>
Execution: <br>
Insert "Intersection A, 30": <br>

Balance factor of A = 0 (tree is balanced). <br>
AVL tree is empty; A becomes the root. <br>
Insert "Intersection B, 50": <br>

Balance factor of A = -1 (tree remains balanced). <br>
Insert B to the right of A (since 50 > 30). <br>
Insert "Intersection C, 40": <br>

Balance factor of A = -2 (tree becomes unbalanced). <br>
Insert C to the right of A and left of B (40 lies between 30 and 50). <br>
Perform Right-Left Rotation to restore balance: <br>
Step 1: Rotate B → left (C becomes the new right child of A). <br>
Step 2: Rotate A → right (C becomes the new root). <br>
Insert "Intersection D, 20": <br>

Balance factor of all nodes remains within -1 to 1. <br>
Insert D to the left of C and left of A (20 < 30). <br>
Output: <br>
The AVL tree, represented by In-Order Traversal (sorted by intersections): <br>
 <br>
Intersection A: 30 <br>
Intersection D: 20 <br>
Intersection C: 40 <br>
Intersection B: 50
<br>

For Combined Output : <br>
<hr>
Combined Outputs: <br>
Optimal Sensor Placement (Kruskal's Algorithm): <br>

Selected edges for Minimum Spanning Tree: <br>
(0-1, weight 1), (1-3, weight 1), (1-2, weight 2). <br>
Shortest Paths (Dijkstra's Algorithm): <br>

A → B: 1 <br>
A → C: 3 <br>
A → D: 6 <br>
Traffic Data (AVL Tree): <br>

Intersection D: 20 <br>
Intersection A: 30 <br>
Intersection C: 40 <br>
Intersection B: 50




            </strong>
        </div>
        
        
       
        

        
        
                
       



        

        <!-- Footer Start -->
        <div class="container-fluid bg-dark text-light footer mt-5 pt-5 wow fadeIn" data-wow-delay="0.1s">
            <div class="container py-5 px-lg-5">
                <div class="row">
                    <!-- Footer Branding -->
                    <div class="col-lg-6 col-md-6">
                        <h5 class="text-uppercase mb-3" style="color:white">DAA Portfolio</h5>
                        <p class="mb-0">
                            Dedicated to showcasing projects and real-world applications of advanced algorithms and data structures.
                        </p>
                    </div>
        
                    <!-- Quick Links -->
                    <div class="col-lg-3 col-md-6 mt-4 mt-md-0">
                        <h5 class="text-uppercase "  style="color:white">Quick Links</h5>
                        <ul class="list-unstyled">
                            <li><a href="index.html" class="text-light text-decoration-none">About</a></li>
                            <li><a href="courseproject.html" class="text-light text-decoration-none">Projects</a></li>
                            <li><a href="koturpritesh@gmail.com" class="text-light text-decoration-none">Contact</a></li>
                        </ul>
                    </div>
        
                    <!-- Contact Information -->
                    <div class="col-lg-3 col-md-6 mt-4 mt-md-0">
                        <h5 class="text-uppercase mb-3"  style="color:white">Contact Us</h5>
                        <p class="mb-1">
                            <i class="fas fa-envelope me-2"></i>koturpritesh@gmail.com
                        </p>
                        <p class="mb-0">
                            <i class="fas fa-phone-alt me-2"></i>+91 90199 68839
                        </p>
                    </div>
                </div>
        
                <hr class="my-4 border-light">
                
                <!-- Footer Bottom -->
                <div class="row text-center">
                    <div class="col-12">
                        <p class="mb-0">
                            &copy; 2024 DAA Portfolio. All Rights Reserved.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <!-- Footer End -->


        <!-- Back to Top -->
        <a href="#" class="btn btn-lg btn-primary btn-lg-square back-to-top pt-2"><i class="bi bi-arrow-up"></i></a>
    </div>

    <!-- JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="lib/wow/wow.min.js"></script>
    <script src="lib/easing/easing.min.js"></script>
    <script src="lib/waypoints/waypoints.min.js"></script>
    <script src="lib/owlcarousel/owl.carousel.min.js"></script>
    <script src="lib/isotope/isotope.pkgd.min.js"></script>
    <script src="lib/lightbox/js/lightbox.min.js"></script>

    <!-- Template Javascript -->
    <script src="js/main.js"></script>
</body>

</html>
